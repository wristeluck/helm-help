#include <PID_v1.h>
#include <mmc.h>
#include <avr/eeprom.h>
#include "file_store.h"
#include "I2Cdev.h"
#include "MPU6050_6Axis_MotionApps20.h"
//#include <MPU6050.h>
//#include "mpu6050util.h"

// Arduino Wire library is required if I2Cdev I2CDEV_ARDUINO_WIRE implementation
// is used in I2Cdev.h
#if I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE
    #include "Wire.h"
#endif

// Pin assignments
#define PIN_SERVO        9  // must be a PWM  
#define PIN_LCD_RS       4 
#define PIN_LCD_EN       7
#define PIN_LCD_D4      14
#define PIN_LCD_D5      15
#define PIN_LCD_D6      16
#define PIN_LCD_D7      17
#define PIN_ROT_A        3 // INT1
#define PIN_ROT_B        8
//#define PIN_ROT_PORT     PINB
#define PIN_ROT_PUSH    A6 // using analog input
#define PIN_ROT_LED_R    5
#define PIN_ROT_LED_G    6
#define PIN_ROT_LED_B    0 // no spare pins!!!


#define LCD_CHARS   16
#define LCD_LINES    2


// LCD
#include <LiquidCrystal.h>
LiquidCrystal lcd(PIN_LCD_RS, PIN_LCD_EN, PIN_LCD_D4, PIN_LCD_D5, PIN_LCD_D6, PIN_LCD_D7);

// servo
#include <Servo.h> 
Servo myservo;  // create servo object to control a servo 
                // a maximum of eight servo objects can be created 

// SD card logger
FileStore fileStore(640); // catalog (first) sector of data file

// class default I2C address is 0x68
// specific I2C addresses may be passed as a parameter here
// AD0 low = 0x68 (default for SparkFun breakout and InvenSense evaluation board)
// AD0 high = 0x69
MPU6050 mpu;
//MPU6050 mpu(0x69); // <-- use for AD0 high

/* =========================================================================
   NOTE: In addition to connection 3.3v, GND, SDA, and SCL, this sketch
   depends on the MPU-6050's INT pin being connected to the Arduino's
   external interrupt #0 pin. On the Arduino Uno and Mega 2560, this is
   digital I/O pin 2.
 * ========================================================================= */

//#define LED_PIN 13 
//long last_blink = 0;
bool led_on = false;

// MPU control/status vars
//bool dmpReady = false;  // set true if DMP init was successful
// expected DMP packet size (default is 42 bytes)
#define MPU_PACKET_SIZE 42
uint16_t fifoCount;     // count of all bytes currently in FIFO


// PID stuff
//Define Variables we'll be connecting to
double target_yaw, current_yaw, rudder_angle; // setpoint, input, output

//Define the default Tuning Parameters
// kp=0.5, ki=0.2, kd=0.1;
// TODO read the PID parameters from EEPROM
uint16_t EEMEM kp;
uint16_t EEMEM ki;
uint16_t EEMEM kd;
byte  EEMEM db;
PID myPID(&current_yaw, &rudder_angle, &target_yaw, 1.0, 0.4, 0.2, DIRECT);

byte deadband = 1;  // default 1 degree
boolean autoSteer = false;
boolean initialized = false;

// TODO move the following into a structure
// see http://books.google.co.uk/books?id=U6EtJwBzY1oC&amp;pg=PA100&amp;lpg=PA100&amp;dq=arduino+maximum+binary+sketch+size&amp;source=bl&amp;ots=EcziTPs6kG&amp;sig=N3RMoImznXxLGF3fwiNETKX-gBY&amp;hl=en&amp;sa=X&amp;ei=KDd-VOquKI3pasuUgfgO&amp;ved=0CEwQ6AEwBQ
int error_plot_period = 0; // milliseconds - 0 means error_plot off
long error_plot_last_datum;
unsigned char error_plot_range = 30; // +/- degrees

// Serial command line buffers
char request_buffer[32];
byte request_index = 0;
static void process_command(char *command);

// serial streaming support
template<class T> inline Print &operator <<(Print &obj, T arg) { obj.print(arg); return obj; }

long buttonTime = millis();
long rotaryTime = millis();
boolean isPressed = false;

typedef enum { E_ROT_INC, E_ROT_DEC, E_CLICK, E_LONG_CLICK } Event;
typedef struct FSM StateMachine; 
typedef void (*EventHandler)(StateMachine *sm, Event input);   
void checkButton();
void trigger(Event event);

struct FSM 
{ 
  EventHandler state; 
};

void fsm_manual(StateMachine *fsm, Event event);
void fsm_kp(StateMachine *fsm, Event event);
void fsm_ki(StateMachine *fsm, Event event);
void fsm_kd(StateMachine *fsm, Event event);
void fsm_db(StateMachine *fsm, Event event);
void fsm_save(StateMachine *fsm, Event event);
void fsm_reset(StateMachine *fsm, Event event);

StateMachine ui = { fsm_manual };

boolean eventRaised = true;

// GPS
#define GPS
#ifdef GPS

char gps_buffer[80];
int gps_index = 0;
char gps_line[] = "Waiting for GPS.";  // test data

static void process_gps_sentence(char *sentence);

#endif //GPS

// ================================================================
// ===               INTERRUPT DETECTION ROUTINE                ===
// ================================================================

volatile bool mpuInterrupt = false;     // indicates whether MPU interrupt pin has gone high
void dmpDataReady() {
    mpuInterrupt = true;
}

void decoder()
//very short interrupt routine 
//Remember that the routine is only called when pin1
//changes state, so it's the value of pin2 that we're
//interrested in here
{
  if(millis() - rotaryTime > 5) {
    if (digitalRead(PIN_ROT_A) == digitalRead(PIN_ROT_B)) {
      trigger(E_ROT_INC); //if encoder channels are the same, direction is CW
    } else {
      trigger(E_ROT_DEC); //if they are not the same, direction is CCW
    }
    rotaryTime = millis();
  }
}

int freeRam () {
  extern int __heap_start, *__brkval; 
  int v; 
  return (int) &v - (__brkval == 0 ? (int) &__heap_start : (int) __brkval); 
}


// ================================================================
// ===                      INITIAL SETUP                       ===
// ================================================================

void setup() {
    // join I2C bus (I2Cdev library doesn't do this automatically)
    #if I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE
        Wire.begin();
        TWBR = 24; // 400kHz I2C clock (200kHz if CPU is 8MHz)
    #elif I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE
        Fastwire::setup(400, true);
    #endif

    pinMode(PIN_ROT_PUSH, INPUT_PULLUP); // sets analog pin for input 

    lcd.begin(LCD_CHARS, LCD_LINES);

    Serial.begin(9600); // speed of GPS NMEA

    fileStore.initialiseCatalog();

    // initialize device
    lcd.setCursor(0, 1);
    lcd.print(F("Init I2C..."));
    mpu.initialize();

    // verify connection
//    Serial.println(F("Testing device connections..."));
//    Serial.println(mpu.testConnection() ? F("MPU6050 connection successful") : F("MPU6050 connection failed"));

    // load and configure the DMP
//    Serial.println(F("Initializing DMP..."));
    uint8_t devStatus = mpu.dmpInitialize();
//    uint8_t devStatus = dmpInitialize(mpu, fileStore);

    // supply your own gyro offsets here, scaled for min sensitivity
    mpu.setXAccelOffset(-931);
    mpu.setYAccelOffset(-2082);
    mpu.setZAccelOffset(1374);
    mpu.setXGyroOffset(26);
    mpu.setYGyroOffset(-32);
    mpu.setZGyroOffset(-5);

    // make sure it worked (returns 0 if so)
    if (devStatus == 0) {
        // turn on the DMP, now that it's ready
        mpu.setDMPEnabled(true);

        // enable Arduino interrupt detection
        attachInterrupt(0, dmpDataReady, RISING);
//        uint8_t mpuIntStatus = mpu.getIntStatus();

        // set our DMP Ready flag so the main loop() function knows it's okay to use it
        lcd.setCursor(0, 1);
        lcd.print(F("DMP ready!"));
//        dmpReady = true;

        // get expected DMP packet size for later comparison
//        packetSize = mpu.dmpGetFIFOPacketSize();
//        Serial.print(F("Packet size .. "));
//        Serial.println(packetSize);
    } else {
        // ERROR!
        // 1 = initial memory load failed
        // 2 = DMP configuration updates failed
        // (if it's going to break, usually the code will be 1)
        lcd.print(F("DMP Init failed: "));
        lcd.println(devStatus);
    }

    // enable interrupt for rotary encoder
    attachInterrupt(1, decoder, LOW);
    pinMode(PIN_ROT_PUSH, INPUT); // sets analog pin for input 
    pinMode(PIN_ROT_A, INPUT_PULLUP);  
    pinMode(PIN_ROT_B, INPUT_PULLUP); // sets analog pin for input 

    // initialise PID algorithm
    myPID.SetOutputLimits(0, 180);
    
    // read PID parameters from EEPROM
    uint16_t eeprom_kp = eeprom_read_word(&kp);
    uint16_t eeprom_ki = eeprom_read_word(&ki);
    uint16_t eeprom_kd = eeprom_read_word(&kd);
    deadband = eeprom_read_byte(&db);
    myPID.SetTunings(eeprom_kp, eeprom_ki, eeprom_kd);

    // initialise serve
    myservo.attach(PIN_SERVO);
    rudder_angle = 90;  // servo in centre position
    
    fileStore.logSeparator();
}



// ================================================================
// ===                    MAIN PROGRAM LOOP                     ===
// ================================================================

void loop() {
    checkButton();

    // handle Serial CLI
#ifdef NEVER
    if(Serial.available()) {
      // this relies on all of the data being available at once (within this do...while loop)

      do {
        char aChar = Serial.read();
        if(aChar == '\n') {
          // End of command.
    Serial << "eol: " << request_buffer << "\n";
          process_command(request_buffer);
          request_index = 0;
          request_buffer[request_index] = NULL;
          break;
        } else {
          request_buffer[request_index] = aChar;
          request_index++;
          request_buffer[request_index] = '\0'; // Keep the string NULL terminated
        }
      } while(Serial.available());
    }
#endif

#ifdef GPS
    // check GPS
    if(Serial.available()) {
      do {
        char aChar = Serial.read();
        if((aChar == '$' && gps_index > 0) || gps_index >= 78) {
          // End of command.
//      Serial.println(gps_buffer);
          process_gps_sentence(gps_buffer);
          memset(gps_buffer, 0, 80);
          gps_index = 1;
          gps_buffer[0] = '$';
//          gps_buffer[1] = NULL;
        } else {
          gps_buffer[gps_index] = aChar;
          gps_index++;
          if(gps_index > 78) {
            Serial << "*** GPS overflow: " << gps_index << " -> " << aChar << "\n";
          }
          gps_buffer[gps_index] = '\0'; // Keep the string NULL terminated
 //     Serial.println(gps_buffer);
        }
      } while(Serial.available());
    }
#endif //GPS

/*
    // error plot
    if(error_plot_period && ((error_plot_last_datum + error_plot_period) < millis())) {
      // write a new plot point
      // |                               |                              |
      byte datum = (byte)(39 * (target_yaw - current_yaw) / error_plot_range) + 39;
      char line[80];
      memset(line, 0x20, 79);
      line[79] = '\0';
      line[datum] = '|';
      Serial << line << "\n";
      error_plot_last_datum = millis();
    }
*/

    // wait for MPU interrupt or extra packet(s) available
    if(mpuInterrupt || fifoCount >= MPU_PACKET_SIZE) {
  
      // reset interrupt flag and get INT_STATUS byte
      mpuInterrupt = false;
      uint8_t mpuIntStatus = mpu.getIntStatus();
  
      // get current FIFO count
      fifoCount = mpu.getFIFOCount();
      
      // check for overflow (this should never happen unless our code is too inefficient)
      if ((mpuIntStatus & 0x10) || fifoCount == 1024) {
          // reset so we can continue cleanly
          mpu.resetFIFO();
          Serial.println(F("FIFO overflow!"));
  
      // otherwise, check for DMP data ready interrupt (this should happen frequently)
      } else if (mpuIntStatus & 0x02) {
           // wait for correct available data length, should be a VERY short wait
          while (fifoCount < MPU_PACKET_SIZE) fifoCount = mpu.getFIFOCount();
  
          //float ypr[3];           // [yaw, pitch, roll]   yaw/pitch/roll container and gravity vector
          //float yaw;
          int32_t qw, qx, qy, qz;  // quaternion
          { // limit scope of fifoBuffer
            uint8_t fifoBuffer[MPU_PACKET_SIZE]; // FIFO storage buffer
            // read a packet from FIFO
            mpu.getFIFOBytes(fifoBuffer, MPU_PACKET_SIZE);
          
            // track FIFO count here in case there is > 1 packet available
            // (this lets us immediately read more without waiting for an interrupt)
            fifoCount -= MPU_PACKET_SIZE;
  
            // get quaternion from fifoBuffer
            qw = ((fifoBuffer[0] << 8) + fifoBuffer[1]);
            qx = ((fifoBuffer[4] << 8) + fifoBuffer[5]);
            qy = ((fifoBuffer[8] << 8) + fifoBuffer[9]);
            qz = ((fifoBuffer[12] << 8) + fifoBuffer[13]);
            current_yaw = atan2((float)(qx*qy - qw*qz), (float)(qw*qw + qx*qx - 134217728l))  * 57.29578;
          } // end of scope of fifoBuffer, q, gravity, ypr (memory released)
          // update the PID
          // before ivoking the compute method, we need to guard against 0/360 degree wrap around
          // confusing the PID and trying to drive the servo the wrong way
          if (current_yaw - target_yaw < -180)
             current_yaw += 360;
          if (current_yaw - target_yaw > 180)
             current_yaw -= 360;

          if(!initialized && millis() > 3000) {
            // turn the PID on
             autoSteer = true;
            target_yaw = current_yaw;
            initialized = true;
          }

          // dead-band - turn off PID if error is below threshold
          if(autoSteer) {
            boolean inDeadband = (abs(target_yaw - current_yaw) < deadband);
            if(inDeadband) {
              myPID.SetMode(MANUAL);
            } else if(myPID.GetMode() == MANUAL) {
              myPID.SetMode(AUTOMATIC);
            }
          }

          if(myPID.Compute()) {
            // new output available
            
/*
            if(!error_plot_period) {
              Serial << target_yaw << "\t" << current_yaw << "\t";
              if(target_yaw > current_yaw) {
                Serial << "R\t";
              } else {
                Serial <<"L\t";
              }
              Serial << rudder_angle;
              if(rudder_angle > 90) {
                Serial << "\tstarboard ";
              } else {
                Serial << "\tport      ";
              }
              Serial << abs(rudder_angle - 90) * 1.1111;
              Serial << "%\t";
              Serial << freeRam();
              Serial << "\n";
            }
  */
            myservo.write(rudder_angle);
            
            refresh_display();
            
            // log to SD card
            long current_time = millis();
//            fileStore.logImu(current_time, current_yaw, ypr[1] * 180/M_PI, ypr[2] * 180/M_PI); // yaw, pitch, roll
            fileStore.logQuaternion(current_time, (int16_t)qw, (int16_t)qx, (int16_t)qy, (int16_t)qz);
            fileStore.logPid(current_time, target_yaw, current_yaw, rudder_angle);
          }
      }
    }
}

void refresh_display() {
  char line[17];
 
   // two screens, depending on state
  if(ui.state == fsm_manual) {
    // screen 1 - steering to fixed heading

    // line 1 - GPS output
    lcd.setCursor(0,0);
    lcd.print(gps_line);

    // line 2 - steering status
    int disp_yaw = (int)target_yaw % 360;
    while(disp_yaw < 0) disp_yaw += 360;
    int disp_error = (int)abs(target_yaw - current_yaw);
    int disp_rudder = (int)(abs(rudder_angle - 90) * 1.1111);
    strcpy(line, "                ");
    format_number(disp_yaw, 0, line+3);
    format_number(disp_error, 0, line+8);
    format_number(disp_rudder, 0, line+14);
    line[14] = '%';
    line[3] = 0xDF;  // degrees
    line[8] = 0xDF;  // degrees
    if(current_yaw > target_yaw) {
      line[5] = 0x7F; // left arrow
    } else {
      line[9] = 0x7E; // right arrow
    }
    if(rudder_angle < 90) {
      line[11] = 0x7F;
    } else {
      line[15] = 0x7E;
    }

    lcd.setCursor(0, 1);
    lcd.print(line);          
  } else {
    // screen 2 - PID setup
    // line 1
    lcd.setCursor(0,0);
    strcpy(line, "Kp=     Ki=     ");
    format_number(myPID.GetKp() / 10, 1, line+7);
    format_number(myPID.GetKi() / 10, 1, line+15);

    if(ui.state == fsm_kp) {
      line[2] = 0x7E; // right arrow
      line[7] = 0x7F; // left arrow
    } else if(ui.state == fsm_ki) {
      line[10] = 0x7E; // right arrow
      line[15] = 0x7F; // left arrow
    }
    lcd.print(line);

    // line 2 
    lcd.setCursor(0,1);
    strcpy(line, "Kd=     Db=   S ");
    format_number(myPID.GetKd() / 10, 1, line+7);
    format_number(deadband, 0, line+13);

    if(ui.state == fsm_reset) {
      line[14] = 'R';
    }
    
    if(ui.state == fsm_kd) {
      line[2] = 0x7E; // right arrow
      line[7] = 0x7F; // left arrow
    } else if(ui.state == fsm_db) {
      line[10] = 0x7E; // right arrow
      line[13] = 0x7F; // left arrow
    } else if(ui.state == fsm_save || ui.state == fsm_reset) {
      line[13] = 0x7E; // right arrow
      line[15] = 0x7F; // left arrow
    }

    lcd.print(line);
  }
}

char *format_number(unsigned x, char shift, char *s) {
//    *--s = 0;
  if(shift) {
    if (!x) *--s = '0';
    for (; x && shift--; x /= 10) {
      *--s = '0' + x % 10;
    }
    *--s = '.';
  } 
  if (!x) *--s = '0';
  for (; x; x /= 10) {
    *--s = '0' + x % 10;
  }
  return s;
}

#ifdef NEVER
static void process_command(char *command) {
  char *varname, *argptr;
  char *saveptr1;
  double value;

  switch(command[0]) {
  case '?': {
    // getter
    varname = strtok_r(command+1, " ,", &saveptr1);
    // valid variables - case insensitive
    // err, kp, ki, kd, kpid, db
    // err can have extra arguments

    if(strcasestr(varname, "kpid")) {
      Serial << "Kp = " << myPID.GetKp() << ", Ki = " << myPID.GetKi() << ", Kd = " << myPID.GetKd();
    } else if(strcasestr(varname, "kp")) {
      Serial << "Kp = " << myPID.GetKp();
    } else if(strcasestr(varname, "ki")) {
      Serial << "Ki = " << myPID.GetKi();
    } else if(strcasestr(varname, "kd")) {
      Serial << "Kd = " << myPID.GetKd();
    } else if(strcasestr(varname, "db")) {
      Serial << "Deadband = " << deadband;
    } else if(strcasestr(varname, "err")) {
      double err = target_yaw - current_yaw;
      //  handle the optional arguments
      argptr = strtok_r(NULL, " ,", &saveptr1);
      if(argptr == NULL) {
        // just print the error
        if(target_yaw > current_yaw) {
          Serial << "Error = " << abs(err) << " L";
        } else {
          Serial << "Error = " << abs(err) << " R";
        }
      } else {
        if(*argptr == 'p') {
          // plot the errors
          Serial << "Error plot\n";
          error_plot_period = 1000; 
          error_plot_range = 30;
          error_plot_last_datum = millis() - error_plot_period;
        }
      }
    } else if(strcasestr(varname, "auto")) {
      Serial << "AutoSteer: " << autoSteer;
    }
    break;
  }
  case 'q': {
    // stop plotting
    error_plot_period = 0;
    break;
  }
  case '=': {
    // setter
    varname = strtok_r(command+1, " ,", &saveptr1);
    argptr = strtok_r(NULL, " ,", &saveptr1);
    if(argptr == NULL) {
      // report error: no value given
      break;
    }
    // valid variables - case insensitive
    // kp, ki, kd, kpid, db
    // kpid takes 3 arguments
    value = atof(argptr);
    if(strcasestr(varname, "kpid")) {
      // get the next 2 arguments
      argptr = strtok_r(NULL, " ,", &saveptr1);
      if(argptr == NULL) {
        // report error: no value given
        break;
      }
      double ki_val = atof(argptr);
      argptr = strtok_r(NULL, " ,", &saveptr1);
      if(argptr == NULL) {
        // report error: no value given
        break;
      }
      double kd_val = atof(argptr);
      myPID.SetTunings(value, ki_val, kd_val);
      eeprom_write_word(&kp, (uint16_t)(value * 100));
      eeprom_write_word(&ki, (uint16_t)(ki_val * 100));
      eeprom_write_word(&kd, (uint16_t)(kd_val * 100));
    } else if(strcasestr(varname, "kp")) {
      myPID.SetTunings(value, myPID.GetKi(), myPID.GetKd());
      eeprom_write_word(&kp, (uint16_t)(value * 100));
    } else if(strcasestr(varname, "ki")) {
      myPID.SetTunings(myPID.GetKp(), value, myPID.GetKd());
      eeprom_write_word(&ki, (uint16_t)(value * 100));
    } else if(strcasestr(varname, "kd")) {
      myPID.SetTunings(myPID.GetKp(), myPID.GetKi(), value);
      eeprom_write_word(&kd, (uint16_t)(value * 100));
    } else if(strcasestr(varname, "db")) {
      deadband = (byte)value;
      eeprom_write_byte(&db, deadband);
    }
    // TODO write these values into EEPROM
    fileStore.logPidParam(millis(), myPID.GetKp(), myPID.GetKi(), myPID.GetKd(), deadband);
    Serial << "Set " << varname << " to " << value;
    break;
  }
  case 'l':
  case 'L': {
    // left
    argptr = strtok_r(command+1, " ,", &saveptr1);
    value = atof(argptr);
    target_yaw -= value;
    Serial << "Left " << value << " degrees";
    break;
  }
  case 'r':
  case 'R': {
    // right
    argptr = strtok_r(command+1, " ,", &saveptr1);
    value = atof(argptr);
    target_yaw += value;
    Serial << "Right " << value << " degrees";
    break;
  }
  case 'c':
  case 'C': {
    // comment to log

    break;
  }
  }
  Serial << "\n";
}
#endif // NEVER

#ifdef GPS
static void process_gps_sentence(char *sentence) {
//   Serial << "GPS: "<<  sentence << "\n"; 
  // only care about $GPRMC sentences
  /*
  $GPRMC,123519,A,4807.038,N,01131.000,E,022.4,084.4,230394,003.1,W*6A

Where:
     RMC          Recommended Minimum sentence C
     123519       Fix taken at 12:35:19 UTC
     A            Status A=active or V=Void.
     4807.038,N   Latitude 48 deg 07.038' N
     01131.000,E  Longitude 11 deg 31.000' E
     022.4        Speed over the ground in knots
     084.4        Track angle in degrees True
     230394       Date - 23rd of March 1994
     003.1,W      Magnetic Variation
     *6A          The checksum data, always begins with *
   */
   
  char *ptr;
  char *saveptr;
  char *timeptr;
  if(strstr(sentence, "$GPRMC")) {
    // time
    ptr = strtok_r(sentence+7, ",", &saveptr);
    timeptr = ptr;
    
    // active or void?
    ptr = strtok_r(NULL, ",", &saveptr);
    // TODO if void, abandon and return immediately
    if(*ptr == 'V') {
      gps_line[15] = 'V';
      return;
    }
    // latitude
    ptr = strtok_r(NULL, ",", &saveptr);
    double latitude = atof(ptr+2) * 0.0166667; // divide by 60
    *(ptr+2) = '\0';
    latitude += atoi(ptr);
    ptr = strtok_r(NULL, ",", &saveptr);
    if(*ptr == 'S') {
      latitude *= -1.0;
    } // otherwise N - positive lat

    // longitude
    ptr = strtok_r(NULL, ",", &saveptr);
    double longitude = atof(ptr+3) * 0.0166667; // divide by 60
    *(ptr+2) = '\0';
    longitude += atoi(ptr);
    ptr = strtok_r(NULL, ",", &saveptr);
    if(*ptr == 'W') {
      longitude *= -1.0;
    } // otherwise E - positive long

    // speed *10
    ptr = strtok_r(NULL, ",", &saveptr);
    int speed_knots = (int)(10.0 * atof(ptr));

    // heading *10   
    ptr = strtok_r(NULL, ",", &saveptr);
    int track_angle = (int)(10.0 * atof(ptr));

    // date
    ptr = strtok_r(NULL, ",", &saveptr);
    // combine with the time
    strncpy(sentence, ptr, 6);
    strncpy(sentence+6, timeptr, 6);
    // TODO - this may need null terminating
    sentence[12] = '\0';
  
    Serial << "***GPS: "<<  sentence << ", " << latitude << ", " << longitude << ", " << speed_knots << ", " << track_angle << "\n"; 
    // log GPS data
    fileStore.logGps(millis(), sentence, latitude, longitude, speed_knots, track_angle);
    // set the lcd line
    strcpy(gps_line, "    kn         A");
    format_number(speed_knots, 1, gps_line+4);
    format_number(track_angle, 1, gps_line+13);
    gps_line[13] = 0xDF;  // degrees
    
    refresh_display();
  }
}
#endif //GPS

void checkButton() {
 // ignore anything that happens within 5 ms of last activity (de-bounce)
  if(buttonTime == 0) {
    boolean buttonPushed = (analogRead(6) > 512);
    if(!buttonPushed) {  // button finally release after LongClick
      isPressed = false;
      buttonTime = millis();
    }
    return;
  }
  if(millis() - buttonTime > 5) {
    if(!isPressed) {  // currently not pressed
      boolean buttonPushed = (analogRead(6) > 512);
      if(buttonPushed) {  // button now pressed
        isPressed = true;
        buttonTime = millis();
      }
    } else {  // currently pressed
      boolean buttonPushed = (analogRead(6) > 512);
      if(buttonPushed && millis() - buttonTime > 1000) {
        // *** FIRE LongClick event
        trigger(E_LONG_CLICK);
        buttonTime = 0; // signals the need to wait until button is released
      }
      if(!buttonPushed) {
        // *** FIRE Click event
        trigger(E_CLICK);
        isPressed = false;
        buttonTime = millis();
      }
    }
  }
}

void trigger(Event event) {
  Serial.print("Event: ");
  Serial.println(event);
  (ui.state)(&ui, event);
  eventRaised = true;
}

void fsm_manual(StateMachine *fsm, Event event) {
  switch(event) {
    case E_ROT_INC:
      target_yaw++;
      break;
    case E_ROT_DEC:
      target_yaw--;
      break;
    case E_CLICK:
      // no-op
      break;
    case E_LONG_CLICK:
      fsm->state = fsm_kp;
      break;
  }
}

void fsm_kp(StateMachine *fsm, Event event) {
  switch(event) {
    case E_ROT_INC:
      myPID.SetTunings(myPID.GetKp() + 10, myPID.GetKi(), myPID.GetKd());
      break;
    case E_ROT_DEC:
      if(myPID.GetKp() > 0)
        myPID.SetTunings(myPID.GetKp() - 10, myPID.GetKi(), myPID.GetKd());
      break;
    case E_CLICK:
      fsm->state = fsm_ki;
      break;
    case E_LONG_CLICK:
      fsm->state = fsm_save;
      break;
  }
}

void fsm_ki(StateMachine *fsm, Event event) {
  switch(event) {
    case E_ROT_INC:
      myPID.SetTunings(myPID.GetKp(), myPID.GetKi() + 10, myPID.GetKd());
      break;
    case E_ROT_DEC:
      if(myPID.GetKi() > 0)
        myPID.SetTunings(myPID.GetKp(), myPID.GetKi() - 10, myPID.GetKd());
      break;
    case E_CLICK:
      fsm->state = fsm_kd;
      break;
    case E_LONG_CLICK:
      fsm->state = fsm_save;
      break;
  }
}

void fsm_kd(StateMachine *fsm, Event event) {
  switch(event) {
    case E_ROT_INC:
      myPID.SetTunings(myPID.GetKp(), myPID.GetKi(), myPID.GetKd() + 10);
      break;
    case E_ROT_DEC:
      if(myPID.GetKd() > 0)
      myPID.SetTunings(myPID.GetKp(), myPID.GetKi(), myPID.GetKd() - 10);
      break;
    case E_CLICK:
      fsm->state = fsm_db;
      break;
    case E_LONG_CLICK:
      fsm->state = fsm_save;
      break;
  }
}

void fsm_db(StateMachine *fsm, Event event) {
  switch(event) {
    case E_ROT_INC:
      deadband++;
      break;
    case E_ROT_DEC:
      deadband--;
      break;
    case E_CLICK:
      fsm->state = fsm_kp;
      break;
    case E_LONG_CLICK:
      fsm->state = fsm_save;
      break;
  }
}

void fsm_save(StateMachine *fsm, Event event) {
  switch(event) {
    case E_ROT_INC:
      fsm->state = fsm_reset;
      break;
    case E_ROT_DEC:
      fsm->state = fsm_reset;
      break;
    case E_CLICK:
      // save the values to EEPROM
      fsm->state = fsm_manual;
      break;
    case E_LONG_CLICK:
      fsm->state = fsm_kp;
      break;
  }
}

void fsm_reset(StateMachine *fsm, Event event) {
  switch(event) {
    case E_ROT_INC:
      fsm->state = fsm_save;
      break;
    case E_ROT_DEC:
      fsm->state = fsm_save;
      break;
    case E_CLICK:
    {
      // restore PID parameters from EEPROM
      uint16_t eeprom_kp = eeprom_read_word(&kp);
      uint16_t eeprom_ki = eeprom_read_word(&ki);
      uint16_t eeprom_kd = eeprom_read_word(&kd);
      deadband = eeprom_read_byte(&db);
      myPID.SetTunings(eeprom_kp, eeprom_ki, eeprom_kd);
      
      fsm->state = fsm_manual;
      break;
    }
    case E_LONG_CLICK:
      fsm->state = fsm_kp;
      break;
  }
}

